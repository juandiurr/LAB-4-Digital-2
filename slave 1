/*
 * LAB 4 digital 2 slave 1.c
 *
 * Created: 2/08/2024 10:42:00
 * Author : diego
 */ 
#define SlaveAddress 0x30
#define F_CPU 16000000UL
#include <avr/io.h>
#include <stdint.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "Librerias/I2CS.h"
#include "Librerias/ADC.h"

volatile uint8_t buffer1 = 0;//variable de recepción de datos
volatile uint8_t buffer2 = 0;//variable de transmición de datos
int main(void)
{
	cli();
	ADC_(128);
	ADC0();
	I2C_slave_init(SlaveAddress);
	sei();
    /* Replace with your application code */
    while (1) 
    {
		ADCSRA |= (1<<ADSC);//HABILITAR CONVERSION
		_delay_ms(100);
    }
}

ISR(TWI_vect){//interrupcion del esclavo
	uint8_t estado;
	estado = TWSR & 0xF8;
	//el esclavo manda dato a maestro:
	switch(estado){
		case 0xA8://se ha recibido la instruccion de mandar dato, se mando ACK
		case 0xB0: //no se ha rcibido instr W/R, lo toma como R y se manda ACK
			TWDR = buffer2;
			TWCR |= (1<<TWINT);
		break;
		case 0xB8: //se mando el dato en TWDR se recibio ack
		case 0xC0: //se mando el dato en TWDR, no se recibió ack
			TWCR |= (1<<TWINT) | (1<<TWEN);
		break;
		default://se libera el bus de cualquier error
			TWCR |= (1<<TWINT) | (1<<TWSTO);
		break;
	}
	//El maestro escribe al esclavo
	/*switch(estado){
		case 0x60://se recibió y se mandó ACK
		case 0x70://llamada general y se mandó ACK
			TWCR |= (1<<TWINT);
			break;
		case 0x80://se recibió dirección, se ha recibido data, ack se ha mandado
		case 0x90://llamada general se recibió, se ha recibido data, ack se ha mandado
			buffer1 = TWDR;
			TWCR |= (1<<TWINT);
			break;
		default://se libera el bus de cualquier error
			TWCR |= (1<<TWINT) | (1<<TWSTO);
		break;*/
}
ISR(ADC_vect){
	buffer2 = ADCH;
	ADCSRA |= (1<<ADIF); //apagar bandera
}
